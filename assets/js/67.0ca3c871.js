(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{199:function(t,a,e){"use strict";e.r(a);var r=e(0),_=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"seo-思考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#seo-思考"}},[t._v("#")]),t._v(" SEO 思考")]),t._v(" "),e("h2",{attrs:{id:"更新"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#更新"}},[t._v("#")]),t._v(" 更新")]),t._v(" "),e("p",[t._v("目前采用 Nextjs + Eggjs 这一套来实现页面的 SSR。页面数据如果不是经常变化的话，可以把页面进行缓存，可以采用 LRU 缓存算法。")]),t._v(" "),e("h2",{attrs:{id:"一、项目背景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、项目背景"}},[t._v("#")]),t._v(" 一、项目背景")]),t._v(" "),e("ul",[e("li",[t._v("一个社区项目 (SEO 强相关)")]),t._v(" "),e("li",[t._v("使用 "),e("code",[t._v("python")]),t._v(" + "),e("code",[t._v("jinja")]),t._v(" (模板引擎) + "),e("code",[t._v("React")]),t._v(" + "),e("code",[t._v("Jquery")]),t._v(" 实现")]),t._v(" "),e("li",[t._v("前后端不分离")])]),t._v(" "),e("p",[t._v("由于项目的代码几经人手，目前代码比较混乱，有重构的想法。想使用 React 的模块化，组件化来重构， 但是考虑到 SEO 问题，因此有了这篇文章。")]),t._v(" "),e("p",[t._v("因为这个是社区项目，因此 SEO 还是很重要的。")]),t._v(" "),e("h2",{attrs:{id:"二、seo-解决方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、seo-解决方案"}},[t._v("#")]),t._v(" 二、SEO 解决方案")]),t._v(" "),e("p",[t._v("虽然 Google 支持 JS 渲染，但是国内的百度不支持呀，所以只能放弃纯 JS 渲染的这种做法了。")]),t._v(" "),e("h3",{attrs:{id:"_2-1-针对搜索引擎返回静态页面"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-针对搜索引擎返回静态页面"}},[t._v("#")]),t._v(" 2.1 针对搜索引擎返回静态页面")]),t._v(" "),e("p",[t._v("用户访问的时候，还是使用客户端渲染，只是针对爬虫返回特定的静态页面。")]),t._v(" "),e("h3",{attrs:{id:"_2-2-采用-ssr-渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-采用-ssr-渲染"}},[t._v("#")]),t._v(" 2.2 采用 SSR 渲染")]),t._v(" "),e("p",[t._v("SSR（server side render），首屏加载速度快， 且 SEO 友好。")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://nextjs.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Nextjs"),e("OutboundLink")],1),t._v(" 的 React SSR 渲染")]),t._v(" "),e("li",[e("a",{attrs:{href:"https://github.com/alibaba/beidou/blob/master/packages/beidou-docs/articles/high-performance-isomorphic-app.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("Alibaba 的 Beidou 框架"),e("OutboundLink")],1)]),t._v(" "),e("li",[t._v("node + nunjucks(模板引擎) + Jquery")])]),t._v(" "),e("h2",{attrs:{id:"三、各个方案的优缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、各个方案的优缺点"}},[t._v("#")]),t._v(" 三、各个方案的优缺点")]),t._v(" "),e("h3",{attrs:{id:"_3-1-针对搜索引擎返回静态页面"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-针对搜索引擎返回静态页面"}},[t._v("#")]),t._v(" 3.1 针对搜索引擎返回静态页面")]),t._v(" "),e("p",[t._v("简单粗暴，针对搜索引擎优化，而不是针对用户优化。")]),t._v(" "),e("h4",{attrs:{id:"优点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),e("ul",[e("li",[t._v("用户看到的是纯前端渲染得页面，开发方式保留常规的开发方式即可。")]),t._v(" "),e("li",[t._v("使用 nginx 部署静态站点，方便快捷")])]),t._v(" "),e("h4",{attrs:{id:"缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),e("ul",[e("li",[t._v("针对搜索引擎优化，而非针对用户体验优化。")]),t._v(" "),e("li",[t._v("需要一个服务，当爬虫抓取页面的时候，返回一个静态页面，(静态页面可以 用 Headless Chrome 生成在返回，也可以自己写一个爬虫抓取自己的页面)")])]),t._v(" "),e("h3",{attrs:{id:"_3-2-nextjs-ssr-渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-nextjs-ssr-渲染"}},[t._v("#")]),t._v(" 3.2 NextJS SSR 渲染")]),t._v(" "),e("blockquote",[e("p",[t._v("alibaba 的 beidou 框架，具体没有用过，但是属于同构开发，跟 Next.js 类似，就放一起了。")])]),t._v(" "),e("p",[t._v("相对浏览器渲染的开发方式，稍微麻烦一点，并且因为由动态路径页面，必须引入 Node 层。")]),t._v(" "),e("h4",{attrs:{id:"_3-2-1-优点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-1-优点"}},[t._v("#")]),t._v(" 3.2.1 优点")]),t._v(" "),e("ul",[e("li",[t._v("SSR 服务端直出，SEO 友好")]),t._v(" "),e("li",[t._v("在移动端下、首屏速度快，对用户友好")])]),t._v(" "),e("h4",{attrs:{id:"_3-2-2-缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-2-缺点"}},[t._v("#")]),t._v(" 3.2.2 缺点")]),t._v(" "),e("ul",[e("li",[t._v("开发相对复杂(这个也还好)")]),t._v(" "),e("li",[t._v("Nextjs 引用图片，只能放在 static 目录下，不能直接用 "),e("code",[t._v("require")]),t._v(" 直接引用图片")])]),t._v(" "),e("h3",{attrs:{id:"_3-3-node-nunjucks-jquery-react"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-node-nunjucks-jquery-react"}},[t._v("#")]),t._v(" 3.3 Node + Nunjucks + Jquery + react")]),t._v(" "),e("p",[t._v("最基础，最早期的 SSR 开发方式，现在用 Jquery 开发起来还是比较麻烦的，并且不好复用。")]),t._v(" "),e("h4",{attrs:{id:"_3-3-1-优点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-1-优点"}},[t._v("#")]),t._v(" 3.3.1 优点")]),t._v(" "),e("ul",[e("li",[t._v("简单")])]),t._v(" "),e("h4",{attrs:{id:"_3-3-2-缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-2-缺点"}},[t._v("#")]),t._v(" 3.3.2 缺点")]),t._v(" "),e("ul",[e("li",[t._v("开发，维护相对比较麻烦")]),t._v(" "),e("li",[t._v("简单的展示页面可以用这个模式，复杂的页面可以用 React 开发，然后注入到页面上。")])]),t._v(" "),e("h2",{attrs:{id:"三、目前尝试过的方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、目前尝试过的方式"}},[t._v("#")]),t._v(" 三、目前尝试过的方式")]),t._v(" "),e("p",[t._v("目前有两个项目进行了尝试")]),t._v(" "),e("ul",[e("li",[t._v("NextJs SSR 支出")]),t._v(" "),e("li",[t._v("Node + Nunjucks 渲染\n"),e("ul",[e("li",[t._v("展示页面，直接用 Nunjucks 写模板直出")]),t._v(" "),e("li",[t._v("交互性页面，则用 React 开发，然后 针对搜索引擎返回特定的内容。")])])])]),t._v(" "),e("h2",{attrs:{id:"参考文章"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[t._v("#")]),t._v(" 参考文章")]),t._v(" "),e("ol",[e("li",[e("a",{attrs:{href:"https://imweb.io/topic/5682938b57d7a6c47914fc00",target:"_blank",rel:"noopener noreferrer"}},[t._v("IMWEB--SEO 优化实战"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://imweb.io/topic/59524be72694079f71f50b0d",target:"_blank",rel:"noopener noreferrer"}},[t._v("IMWEB--使用 HeadlessChrome 做单页应用 SEO"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://cnodejs.org/topic/5865a866189fd5ad6459006c",target:"_blank",rel:"noopener noreferrer"}},[t._v("CNODE--教你如何搭建一个超完美的 React.js 服务端渲染开发环境"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=_.exports}}]);